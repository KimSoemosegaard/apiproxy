##  ====================================================================
##  lib/Utils.pm - utility functions
##  ====================================================================

package @Package@::Utils;

##  Pragmas
use strict;
use warnings;
use open qw(:std :utf8);
use utf8;

##  Packages
use DBI;
use Exporter;
use Text::CSV;


##  Export functions
our @ISA = qw(Exporter);
our @EXPORT = qw(
    str2str str2ascii str2name
    urlencode urldecode urlencodeplus urldecodeplus
    str2sec str2ago
    ip2int int2ip
    imei_checkdigit
);


##  --------------------------------------------------------------------
##  String handling
##  --------------------------------------------------------------------

##  Trim whitespace in string
sub str2str
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    $str =~ s/^\s+|\s+$//gm;
    $str =~ s/\s+/\x20/gm;
    return $str;
}


##  Simplify string by converting into ascii
sub str2ascii
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    # Ligatures
    $str =~ s/Æ/AE/g;
    $str =~ s/æ/ae/g;

    # Diacritics
    $str =~ s/[ÀÁÂÃÄÅ]/A/g;
    $str =~ s/[àáâãäå]/a/g;
    $str =~ s/[Ç]/C/g;
    $str =~ s/[ç]/c/g;
    $str =~ s/[Ð]/D/g;
    $str =~ s/[ð]/d/g;
    $str =~ s/[ÈÉÊË]/E/g;
    $str =~ s/[èéêë]/e/g;
    $str =~ s/[ÌÍÎÏ]/I/g;
    $str =~ s/[ìíîï]/i/g;
    $str =~ s/[Ñ]/N/g;
    $str =~ s/[ñ]/n/g;
    $str =~ s/[ÒÓÔÕÖØ]/O/g;
    $str =~ s/[òóôõöø]/o/g;
    $str =~ s/[ÙÚÛÜ]/U/g;
    $str =~ s/[ùúûü]/u/g;
    $str =~ s/[ÝŸ]/Y/g;
    $str =~ s/[ýÿ]/y/g;
    
    return $str;
}


##  Convert string into a valid variable name
sub str2name
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;
    
    $str = str2ascii($str);
    $str =~ s/[^A-Za-z0-9]+/_/g;
    $str =~ s/^_+|_+$//g;
    $str =~ s/_+/_/g;
    $str =~ s/^([0-9])/_$1/;
    return $str;
}


##  --------------------------------------------------------------------
##  URL encoding
##  --------------------------------------------------------------------

##  URL encode string
sub urlencode
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    utf8::encode($str);
    $str =~ s/([^A-Za-z0-9\-_\.~])/sprintf("%%%02X", ord($1))/seg;
    return $str;
}


##  URL decode string
sub urldecode
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    $str =~ s/\%([A-Fa-f0-9]{2})/chr(hex($1))/seg;
    utf8::decode($str);
    return $str;
}


##  URL encode string using "+" for space characters
sub urlencodeplus
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    utf8::encode($str);
    $str =~ s/([\%\+])/sprintf("%%%02X", ord($1))/seg;
    $str =~ s/\x20/\+/g;
    $str =~ s/([^A-Za-z0-9\-_\.~\%\+])/sprintf("%%%02X", ord($1))/seg;
    return $str;
}


##  URL decode string using "+" for space characters
sub urldecodeplus
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    $str =~ s/\+/\x20/g;
    $str =~ s/\%([A-Fa-f0-9]{2})/chr(hex($1))/seg;
    utf8::decode($str);
    return $str;
}


##  --------------------------------------------------------------------
##  Seconds handling
##  --------------------------------------------------------------------

sub str2sec
{
    my $str = shift;
    defined($str) && !ref($str) or
	return $str;

    $str = str2str($str);
    $str =~ m/^(\d+)$/ and
	return 0 + $1;
    
    my $sec = 0;
    while ($str) {
	if ($str =~ m/^(\d+)s(.*)$/) {
	    $sec += $1; $str = $2; }
	elsif ($str =~ m/^(\d+)m(.*)$/) {
	    $sec += 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)q(.*)$/) {
	    $sec += 15 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)h(.*)$/) {
	    $sec += 60 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)[dD](.*)$/) {
	    $sec += 24 * 60 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)[wW](.*)$/) {
	    $sec += 7 * 24 * 60 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)M(.*)$/) {
	    $sec += 365.25 / 12 * 24 * 60 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)Q(.*)$/) {
	    $sec += 365.25 / 3 * 24 * 60 * 60 * $1; $str = $2; }
	elsif ($str =~ m/^(\d+)Y(.*)$/) {
	    $sec += 365.25 * 24 * 60 * 60 * $1; $str = $2; }
	else {
	    return undef; }
    }

    return $sec;
}


sub str2ago
{
    my $str = str2str(shift);
    my $sec = undef;

    # Seconds
    if ($str =~ s/\b(\d+)\s+(s|sec|secs|second|seconds)\b/ /i) {
	$sec += $1; }
    if ($str =~ s/\b(a)\s+(second)\b/ /i) {
	$sec += 1; }
    if ($str =~ s/\b(\d+)\s*秒前?\b/ /i) {
	$sec += $1; }

    # Minutes
    if ($str =~ s/\b(\d+)\s+(min|mins|minute|minutes)\b/ /i) {
	$sec += $1 * 60; }
    if ($str =~ s/\b(\d+)\s+(m)\b/ /) {
	$sec += $1 * 60; }
    if ($str =~ s/\b(a)\s+(minute)\b/ /i) {
	$sec += 1 * 60; }
    if ($str =~ s/\b(\d+)\s*分钟前?\b/ /i) {
	$sec += $1 * 60; }	

    # Hours
    if ($str =~ s/\b(\d+)\s+(h|hr|hour|hours)\b/ /i) {
	$sec += $1 * 60 * 60; }
    if ($str =~ s/\b(an)\s+(hour)\b/ /i) {
	$sec += 1 * 60 * 60; }
    if ($str =~ s/\b(\d+)\s*小时前?\b/ /i) {
	$sec += $1 * 60 * 60; }

    # Days
    if ($str =~ s/\b(\d+)\s+(d|day|days)\b/ /i) {
	$sec += $1 * 60 * 60 * 24; }
    if ($str =~ s/\b(a)\s+(day)\b/ /i) {
	$sec += 1 * 60 * 60 * 24; }
    if ($str =~ s/\b(\d+)\s*天前?\b/ /i) {
	$sec += $1 * 60 * 60 * 24; }

    # Weeks
    if ($str =~ s/\b(\d+)\s+(w|wk|wks|week|weeks)\b/ /i) {
	$sec += $1 * 60 * 60 * 24 * 7; }
    if ($str =~ s/\b(a)\s+(week)\b/ /i) {
	$sec += 1 * 60 * 60 * 24 * 7; }
    if ($str =~ s/\b(\d+)\s*周前?\b/ /i) {
	$sec += 1 * 60 * 60 * 24 * 7; }

    # Months
    if ($str =~ s/\b(\d+)\s+(mon|month|months)\b/ /i) {
	$sec += $1 * 60 * 60 * 24 * 365.25 / 12; }
    if ($str =~ s/\b(\d+)\s+(M)\b/ /) {
	$sec += $1 * 60 * 60 * 24 * 365.25 / 12; }
    if ($str =~ s/\b(a)\s+(month)\b/ /i) {
	$sec += 1 * 60 * 60 * 24 * 365.25 / 12; }
    if ($str =~ s/\b(\d+)\s*个月前?\b/ /i) {
	$sec += $1 * 60 * 60 * 24 * 365.25 / 12; }

    # Years
    if ($str =~ s/\b(\d+)\s+(y|yr|yrs|year|years)\b/ /i) {
	$sec += $1 * 60 * 60 * 24 * 365.25; }
    if ($str =~ s/\b(a)\s+(year)\b/ /i) {
	$sec += 1 * 60 * 60 * 24 * 365.25; }
    if ($str =~ s/\b(\d+)\s*\年前?b/ /i) {
	$sec += 1 * 60 * 60 * 24 * 365.25; }
    
    return $sec;
}


##  --------------------------------------------------------------------
##  IP address handling
##  --------------------------------------------------------------------

##  Convert ip4 address to integer
sub ip2int
{
    my $ip4 = shift;
    defined($ip4) && !ref($ip4) or
	return $ip4;

    # Validate
    $ip4 =~ m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/ or
	return undef;
    (0 <= $1 && $1 <= 255 &&
     0 <= $2 && $2 <= 255 &&
     0 <= $3 && $3 <= 255 &&
     0 <= $4 && $4 <= 255) or
	return undef;

    # Convert
    return ($1 << 24) + ($2 << 16) + ($3 << 8) + ($4 << 0);
}


##  Convert integer to ip4 address
sub int2ip
{
    my $int = shift;
    defined($int) && !ref($int) or
	return $int;

    # Validate
    $int =~ m/^\d+$/ or
	return undef;
    (0 <= $int && $int <= 0xffffffff) or
	return undef;

    # Convert
    return sprintf("%d.%d.%d.%d",
	($int >> 24) & 0xff,	   
	($int >> 16) & 0xff,	   
	($int >>  8) & 0xff,	   
	($int >>  0) & 0xff);
}


##  --------------------------------------------------------------------
##  IMEI check digit handling
##  --------------------------------------------------------------------

sub imei_checkdigit
{
    my $imei = shift;
    defined($imei) && !ref($imei) or
	return undef;
    $imei =~ m/^[0-9]{14,16}$/ or
	return undef;

    my $result = 0;
    my @digits = (split(//, substr($imei, 0, 14)));
    @digits = map { ord($_) - ord('0') } @digits;
    while (@digits) {
        $result += shift(@digits);
        my $digit = shift(@digits);
        defined($digit) or last;
        $result += ($digit < 5) ? $digit : ($digit - 5) * 2 + 1;
    }

    $result /= 10;
    $result = (10 - $result) % 10;
    return $result;
}


##  --------------------------------------------------------------------
##  End of package
##  --------------------------------------------------------------------

__PACKAGE__;
__END__
